<p id="notice"><%= notice %></p>
<% @user = User.find(params[:id]) %>
  <% if current_user == @user %>
    <h4><%= 'your posts ' %><%= "(#{current_user.posts.count})" %></h4>
  <% else %>
    <h4><%= "#{@user.name}'s posts "%><%= "(#{@user.posts.count})" %>
    </h4>
  <% end %>
  <% @user.posts.sort{ |a,b| b.created_at <=> a.created_at}.each do |post|%>
    <p><%= h(post.message).gsub(/\n/, '<br/>').html_safe %>
      <br>
      <% if post.photo.present? %>
        <%= image_tag post.photo.url(:medium) %>
      <% end %>
      <br>
      <%= "on #{post.created_at.strftime("%d/%m/%Y at %I:%M%p")}" %>
       <% pre_like = post.likes.find { |like| like.user_id == current_user.id} %>
        <% if pre_like %>
        <%= button_to 'Unlike', post_like_path(post, pre_like), method: :delete %>
        <% else %>
        <%= button_to 'Like', post_likes_path(post), method: :post %>
        <% end %> 
        <%= post.likes.count %> <%= (post.likes.count) == 1 ? 'Like' : 'Likes'%>
    <hr>
  <% end %>
  <h4>Friends</h4>
  <% @user.friendships.sort{ |a,b| b.created_at <=> a.created_at}.each do |friendship| %>
    <td><%= link_to friendship.friend.name, friendship.friend %></td>
    —
    <td><%= link_to "Unfriend", friendship, method: :delete %></td>
    <br>
    <br>

  <%end%>

  <% if current_user == @user %>
    <%= link_to 'Edit', edit_user_path(@user) %>
    —
    <%= link_to 'Destroy', @user, method: :delete, data: { confirm: 'Are you sure?' } %>
    —
  <% end %>

  <%= link_to 'Back', users_path %>

<style>
	.links line {
	    stroke: #636363;
	  }
	
	  .nodes circle {
	      fill: #378dbf;
	  stroke: #bfbfbf;
	  }
	
	  text {
	      pointer-events: none;
	  }
</style>
<!-- Load d3.js -->
<div id="friends-graph"></div>
<script src="https://d3js.org/d3.v4.js"></script>
<!-- Friends Graph Visualisation -->
<script>
	margin = ({top: 30, right: 80, bottom: 30, left: 30});
	width = 700 - margin.left - margin.right;
	height = 400 - margin.top - margin.bottom;
	//create a simulation for an array of nodes, and compose the desired forces.
	simulation = d3.forceSimulation()
	    .force("link", d3.forceLink() // This force provides links between nodes
	                    .id(d => d.id) // This sets the node id accessor to the specified function. If not specified, will default to the index of a node.
	     )
	    .force("charge", d3.forceManyBody().strength(-500)) // This adds repulsion (if it's negative) between nodes.
	      .force("center", d3.forceCenter(width / 2, height / 2)); // This force attracts nodes to the center of the svg area
	
	      friendGraph = function () {
	      var svg = d3.select("#friends-graph")
		    .append("svg")
		        .attr("width", width + margin.left + margin.right)
		        .attr("height", height + margin.top + margin.bottom)
		    .append("g")
		        .attr("transform", `translate(${margin.left},${margin.top})`)
	
		      //create dummy data
		    const dataset =  {
		      nodes: [
		        {id: 1, name: 'test'},
		        {id: 2, name: 'test'},
		        {id: 3, name: 'test'},
		        {id: 4, name: 'test'},
		        {id: 5, name: 'test'},
		        {id: 6, name: 'test'}
		      ],
		      links: [
		        {source: 1, target: 5},
		        {source: 4, target: 5},
		        {source: 4, target: 6},
		        {source: 3, target: 2},
		        {source: 5, target: 2},
		        {source: 1, target: 2},
		        {source: 3, target: 4}
	          ]
	        }
	
		    console.log("dataset is ...",dataset);
	
		     // Initialize the links
		    const link = svg.append("g")
		        .attr("class", "links")
		        .selectAll("line")
		        .data(dataset.links)
		      .enter().append("line");
	
		    // Initialize the nodes
		    const node = svg.append("g")
		        .attr("class", "nodes")
		        .selectAll("circle")
		        .data(dataset.nodes)
		      .enter().append("circle")
		        .attr("r", 20)
		        .call(d3.drag()  //sets the event listener for the specified typenames and returns the drag behavior.
		            .on("start", dragstarted) //start - after a new pointer becomes active (on mousedown or touchstart).
		            .on("drag", dragged)      //drag - after an active pointer moves (on mousemove or touchmove).
		            .on("end", dragended)     //end - after an active pointer becomes inactive (on mouseup, touchend or touchcancel).
		         );
	
		    // Text to nodes
		    const text = svg.append("g")
		        .attr("class", "text")
		        .selectAll("text")
		        .data(dataset.nodes)
		      .enter().append("text")
		        .text(d => d.id)
	
		    //Listen for tick events to render the nodes as they update in your Canvas or SVG.
		    simulation
		        .nodes(dataset.nodes)//sets the simulation’s nodes to the specified array of objects, initializing their positions and velocities, and then re-initializes any bound forces;
		        .on("tick", ticked);//use simulation.on to listen for tick events as the simulation runs.
		        // After this, Each node must be an object. The following properties are assigned by the simulation:
		        // index - the node’s zero-based index into nodes
		        // x - the node’s current x-position
		        // y - the node’s current y-position
		        // vx - the node’s current x-velocity
		        // vy - the node’s current y-velocity
	
		    simulation.force("link")
		        .links(dataset.links);//sets the array of links associated with this force, recomputes the distance and strength parameters for each link, and returns this force.
		        // After this, Each link is an object with the following properties:
		        // source - the link’s source node;
		        // target - the link’s target node;
		        // index - the zero-based index into links, assigned by this method
	
	
		    // This function is run at each iteration of the force algorithm, updating the nodes position (the nodes data array is directly manipulated).
		    function ticked() {
		      link.attr("x1", d => d.source.x)
		          .attr("y1", d => d.source.y)
		          .attr("x2", d => d.target.x)
		          .attr("y2", d => d.target.y);
	
		      node.attr("cx", d => d.x)
		          .attr("cy", d => d.y);
	
		      text.attr("x", d => d.x - 5) //position of the lower left point of the text
		          .attr("y", d => d.y + 5); //position of the lower left point of the text
		    }
	
		    //When the drag gesture starts, the targeted node is fixed to the pointer
		    //The simulation is temporarily “heated” during interaction by setting the target alpha to a non-zero value.
		    function dragstarted(d) {
		      if (!d3.event.active) simulation.alphaTarget(0.3).restart();//sets the current target alpha to the specified number in the range [0,1].
		      d.fy = d.y; //fx - the node’s fixed x-position. Original is null.
		      d.fx = d.x; //fy - the node’s fixed y-position. Original is null.
		    }
	
		    //When the drag gesture starts, the targeted node is fixed to the pointer
		    function dragged(d) {
		      d.fx = d3.event.x;
		      d.fy = d3.event.y;
		    }
	
		    //the targeted node is released when the gesture ends
		    function dragended(d) {
		      if (!d3.event.active) simulation.alphaTarget(0);
		      d.fx = null;
		      d.fy = null;
	
		      console.log("dataset after dragged is ...",dataset);
		    }
		  return d3.select("#friends-graph")
	    }
	    friendGraph();
</script>